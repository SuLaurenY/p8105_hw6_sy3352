---
title: "p8105_hw6_sy3352"
author: "Su Yan"
date: "2025-11-23"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(rvest)
library(ggplot2)
set.seed(1)
library(p8105.datasets)
data("weather_df")
theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

## Problem 1
```{r warning=FALSE}
homicides_df = read_csv("data/homicide-data.csv") |> 
  mutate(location = sprintf("%s, %s", city, state),
         solved = case_when(
           disposition == "Closed by arrest" ~ 1, TRUE ~ 0),
         victim_age = as.numeric(victim_age)
         ) |> 
  filter(!location %in% c("Dallas, TX", "Phoenix, AZ", 
                          "Kansas City, MO", "Tulsa, AL"),
         victim_race %in% c("Black", "White"))
```

```{r}
baltimore_df = homicides_df |> 
  filter(location == "Baltimore, MD")

baltimore_fit = baltimore_df |> 
  glm(solved ~ victim_age + victim_race + victim_sex, data = _, 
      family = binomial()) 

baltimore_results = baltimore_fit |> 
  broom::tidy(conf.int = TRUE, exponentiate = TRUE) |> 
  filter(term == "victim_sexMale") |>
  select(term, adjusted_OR = estimate, conf.low, conf.high, p.value) |> 
  knitr::kable(digits = 3)
baltimore_results
```

```{r warning=FALSE}
by_city = homicides_df |> 
  group_by(location) |> 
  nest() |> 
  mutate(glm_model = map(
    data, ~glm(
      solved ~ victim_age + victim_race + victim_sex, 
      data = .x, family = binomial()
  )),
  results = map(glm_model, ~broom::tidy(.x, conf.int = TRUE, 
                                        exponentiate = TRUE))) |> 
  select(location, results) |> 
  unnest(results) |> 
  filter(term == "victim_sexMale") |>
  select(location, adjusted_OR = estimate, conf.low, conf.high, p.value) 
```

```{r}
by_city_plot = by_city |> 
  ggplot(aes(x = reorder(location, adjusted_OR), y = adjusted_OR)) + 
  geom_point(color = "deeppink", size = 2.5) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        plot.title = element_text(hjust = 0.5)) +
  labs(x = "City", y = "Estimated OR of Male vs Female",
       title = "Comparison for Solving Homicides by Victim Sex of Each City")
by_city_plot
```

From the plot, we can see that the adjusted odds ratio varies across cities. Most of the cities have an odds ratio between 0 to 1. This means that overall, homicides with male victims are less likely to be solved compared with cases with female victims after adjusting for age and race. New York, NY has the lowest estimated odds ratio in our analysis, while Albuquerque, NM has the highest (almost 2).

However, looking at the confidence interval, around half cities has its confidence interval across 1, indicating that in half of the cities we have no strong evidence to say that there's a difference in case solve rate between male and female victims. Only in cities whose confidence intervals fall entirely below 1 can we say with confidence that male-victim homicides are solved at lower rates.

## Problem 2
```{r warning=FALSE}
boot_weather = weather_df |> 
  select(tmax, tmin, prcp) |> 
  modelr::bootstrap(n = 5000) |> 
  mutate(models = map(strap, \(df) lm(tmax ~ tmin + prcp, data = df)),
         results = map(models, broom::tidy),
         glances = map(models, broom::glance)) |> 
  select(-strap, -models) |> 
  unnest(glances, results)

boot_results = boot_weather |> 
  select(.id, r.squared, term, estimate) |> 
  pivot_wider(names_from = term, values_from = estimate) |> 
  mutate(ratio = tmin/prcp)

boot_r_plot = boot_results |> 
  ggplot(aes(x = r.squared)) +
  geom_histogram()
boot_r_plot

boot_ratio_plot = boot_results |> 
  ggplot(aes(x = ratio)) +
  geom_histogram()
boot_ratio_plot
```

Across the 5000 bootstrap samples, the distribution of **R²** is bell shaped and approximately symmetric. Most bootstrap estimates fall within a relatively narrow range between 0.93 to 0.95, indicating that the linear model consistently explains a substantial proportion of the variability in `tmax`. This suggests that the relationship between `tmax`, `tmin`, and `prcp` is stable across resampled datasets, and that model fit does not vary dramatically from sample to sample.

However, the distribution of the **β₁ / β₂** ratio is much more variable and noticeably left skewed. Because the precipitation coefficient is relatively small and can vary in sign and magnitude across bootstrap samples, the resulting ratio displays a wider spread and heavier tails. This reflects more uncertainty in comparing the relative effect sizes of `tmin` and `prcp` on `tmax`, and suggests that the ratio is less stable than the **R²**.

```{r}
boot_ci = boot_results |> 
  summarize(
    r.squared_lower = quantile(r.squared, 0.025), 
    r.squared_upper = quantile(r.squared, 0.975),
    ratio_lower = quantile(ratio, 0.025), 
    ratio_upper = quantile(ratio, 0.975)) |> 
  knitr::kable(digits = 3)
boot_ci
```

## Problem 3
```{r}
bwt_df = read_csv("data/birthweight.csv") |> 
  drop_na() |> 
  rename(
    head_cm = bhead, length_cm = blength, mother_wt_deliver = delwt, 
    income_hundreds = fincome, father_race = frace, gestation_week = gaweeks,
    mother_age_mensrche = menarche, mother_height = mheight, 
    mother_age_delivery = momage, mother_race = mrace, previous_lbw_n = pnumlbw,
    previous_small_ges_n = pnumsga, mother_prepreg_bmi = ppbmi, 
    mother_prepreg_wt = ppwt, cig_smoked_n = smoken, mother_wt_gain = wtgain
  ) |> 
  mutate(
    babysex = factor(babysex, levels = c(1,2), labels = c("male", "female")),
    father_race = factor(father_race),
    mother_race = factor(mother_race),
    malform = factor(malform, levels = c(0,1), labels = c("absent", "present"))
  ) 
```

```{r}
proposed_model = bwt_df |> 
  lm(bwt ~ babysex + head_cm + length_cm + mother_wt_deliver + income_hundreds +
       father_race + mother_race + mother_height + mother_age_delivery +
       mother_prepreg_bmi + cig_smoked_n + mother_wt_gain + gestation_week, 
     data = _)
summary(proposed_model)

bwt_df_predict = bwt_df |> 
  modelr::add_predictions(proposed_model) |> 
  modelr::add_residuals(proposed_model)

bwt_predict_pt = bwt_df_predict |> 
  ggplot(aes(x = pred, y = resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, color = "hotpink") +
  labs(x = "Fitted values", y = "Residuals")
bwt_predict_pt
```

To construct a regression model for birth weight, I reviewed the available variables and focusing on factors including parental demographics, maternal physical characteristics, maternal behavior during pregnancy, and gestational age. 

I first cleaned the dataset by converting categorical numeric variables (e.g., baby sex, parental race, malformation indicator) to factors and checking for missing data. After that, I specified a multiple linear regression model with birth weight as the outcome and the following predictors:
- baby’s sex
- maternal weight at delivery
- family income
- father and mother race
- maternal height
- maternal age
- maternal pre-pregnancy BMI
- average number of cigarettes smoked per day
- maternal weight gain during pregnancy
- gestational age in weeks  

These variables reflect biological, demographic, and behavioral determinants of birth weight. I fit the model using `lm()` and evaluated residual diagnostics. To visualize potential issues with linearity or heteroscedasticity, I used `add_predictions()` and `add_residuals()` to create a residual-versus-fitted plot.

```{r}
model_main_effects = bwt_df |> 
  lm(bwt ~ length_cm + gestation_week, data = _)
summary(model_main_effects)

model_interaction = bwt_df |> 
  lm(bwt ~ (head_cm + length_cm + babysex)^3, data = _)
summary(model_interaction)

cv_df = modelr::crossv_mc(bwt_df, 50) |> 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  )

cv_df_fit = cv_df |> 
  mutate(
    main_effect_mod = map(train, \(df) lm(
      bwt ~ length_cm + gestation_week, data = df)
      ),
    interact_mod = map(train, \(df) lm(
      bwt ~ (head_cm + length_cm + babysex)^3, data = df)
      )) |> 
  mutate(
    rmse_main_effect = map2_dbl(
      main_effect_mod, test, \(mod, df) sqrt(
      mean((df$bwt - predict(mod, newdata = df))^2))
    ),
    rmse_interact = map2_dbl(
      interact_mod, test, \(mod, df) sqrt(
      mean((df$bwt - predict(mod, newdata = df))^2))
    ))

cv_df_results = cv_df_fit |> 
  summarize(
    mean_rmse_main_effect = mean(rmse_main_effect),
    mean_rmse_interact = mean(rmse_interact),
    sd_rmse_main_effect = sd(rmse_main_effect),
    sd_rmse_interact = sd(rmse_interact)
  ) |> 
  knitr::kable(digits = 3)
cv_df_results
```

